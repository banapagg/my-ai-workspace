# sub-agents プロジェクト固有ルール

## プロジェクト概要

オーケストレーター・ワーカーパターンとAgent Skillsを使ったサブエージェント環境

## 基本方針

### オーケストレーター優先
- 複雑なタスクはオーケストレーターに委譲する
- オーケストレーターがタスクを分析し、適切なワーカーを選択
- ワーカー間の調整はオーケストレーターが担当

### シンプリシティ
- 複雑なフレームワークより、シンプルで構成可能なパターンを優先
- 各ワーカーは単一の責任を持つ
- Skillsは独立して機能する

### 透明性
- エージェントの計画ステップを明確に表示
- どのワーカーがどのタスクを処理しているかを明示
- 結果の統合プロセスを可視化

## ワーカーの実装ルール

### 新しいワーカーを追加する際
1. `workers/` 配下に新しいディレクトリを作成
2. `README.md` でワーカーの役割と責任を明確に定義
3. 以下の情報を必ず含める:
   - **役割**: このワーカーが担当する専門領域
   - **入力**: 期待する入力の形式
   - **出力**: 提供する出力の形式
   - **制約**: このワーカーができないこと

### ワーカーの責任範囲
- **code_writer**: コード生成のみ（レビューやテストは行わない）
- **code_reviewer**: コードレビューのみ（修正は提案のみ、実装しない）
- **tester**: テスト実行と結果報告のみ（修正は行わない）

## Skillsの実装ルール

### 新しいSkillを追加する際
1. `skills/` 配下に新しいディレクトリを作成
2. `SKILL.md` で以下を定義:
   - **メタデータ**: スキル名と説明
   - **指示**: 具体的な手順
   - **リソース**: 参照ファイル（チェックリスト、テンプレートなど）

### Progressive Disclosure（段階的開示）
- メタデータは常にロードされる（簡潔に）
- 指示は必要時にロード（詳細に）
- リソースは参照時にロード（最も詳細）

### Skillの粒度
- 1つのSkillは1つの専門領域に特化
- 複雑なタスクは複数のSkillを組み合わせる
- 汎用的すぎるSkillは避ける

## タスクの委譲フロー

```
1. ユーザーがタスクを入力
   ↓
2. オーケストレーターがタスクを分析
   - どのワーカーが必要か判断
   - タスクの分割方法を決定
   ↓
3. ワーカーにタスクを委譲
   - 必要なSkillsを動的にロード
   - 各ワーカーが専門タスクを実行
   ↓
4. 結果を統合
   - オーケストレーターが結果を収集
   - 必要に応じて追加のワーカーを起動
   ↓
5. 最終結果をユーザーに報告
```

## ツール設計の原則

（Anthropic公式記事より）

- **モデルにとって自然な形式を選択**
  - 相対パスより絶対パス
  - 複雑な構造よりシンプルな構造
- **エラーハンドリングを丁寧に**
  - エラーメッセージは具体的に
  - 次のアクションを提案する
- **周到なACI（Agent-Computer Interface）設計**
  - ツール最適化に時間をかける
  - モデルのエラーパターンを観察して改善

## 開発の進め方

### フェーズ1: テンプレート（現在）
- 基本構造とテンプレートファイルの作成
- ドキュメントの整備

### フェーズ2: 最小限の動作例
- 1つのワーカー（code_writer）を実装
- 1つのSkill（security-review）を実装
- オーケストレーターの基本ロジックを実装

### フェーズ3: 機能拡張
- 追加のワーカーを実装
- 追加のSkillsを実装
- 並列処理の最適化

### フェーズ4: 実運用
- 実際のプロジェクトで使用
- フィードバックに基づいて改善
- ベストプラクティスの蓄積
